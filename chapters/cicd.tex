\section{les outils utilisés}
\subsection{GitLab CI}

GitLab CI (Continuous Integration) est un système d’intégration et de livraison continues intégré nativement dans GitLab, une plateforme DevOps complète de gestion du cycle de vie applicatif. Il permet d’automatiser la construction, les tests, la validation, le packaging et le déploiement des applications en s’appuyant sur des pipelines définis de manière déclarative. GitLab CI est aujourd’hui largement utilisé dans les organisations souhaitant industrialiser leurs workflows de développement et renforcer la qualité logicielle.

%point de vue metier
GitLab CI répond à plusieurs enjeux stratégiques  : accélérer le time-to-market, réduire les erreurs humaines, renforcer la traçabilité des changements et améliorer la collaboration entre équipes. Grâce à sa proximité avec le dépôt Git, il apporte une cohérence totale entre le code source, l’historique des commits et les pipelines d’automatisation. Il contribue ainsi à la modernisation et à la professionnalisation des processus de développement.

%point de vue logique et technique
GitLab CI repose sur plusieurs concepts essentiels  :
\begin{itemize}
	\item \textbf{Le fichier \texttt{.gitlab-ci.yml}}  : fichier de configuration déclaratif placé à la racine du dépôt, qui décrit les jobs et les étapes du pipeline.
	\item \textbf{Les jobs}  : unités atomiques qui exécutent des scripts ou des commandes (build, test, deploy).
	\item \textbf{Les stages}  : regroupements logiques des jobs (par exemple, build, test, deploy) exécutés séquentiellement ou en parallèle.
	\item \textbf{Les runners}  : exécutants (machines ou conteneurs) qui traitent les jobs. Ils peuvent être partagés, spécifiques ou autoscalés.
	\item \textbf{Les variables}  : valeurs dynamiques injectées dans les pipelines (clés, secrets, paramètres d’environnement).
	\item \textbf{Les artefacts}  : fichiers générés par les jobs et transmis entre étapes.
\end{itemize}

GitLab CI prend en charge de nombreuses fonctionnalités avancées  : intégration Kubernetes, déclencheurs manuels (manual actions), pipelines multi-projets, stratégies de déploiement progressif et vérification des politiques de sécurité.

\textbf{Exemples et cas d’usage} :
\begin{itemize}
	\item Compiler automatiquement une application dès la création d’une merge request.
	\item Exécuter des tests unitaires et fonctionnels dans un pipeline parallèle.
	\item Formater le code source et analyser les dependences pour détecter les vulnérabilités.
	\item Conteneuriser une application et la pousser vers un registre.
	\item Déployer des applications sur Kubernetes via Helm ou kubectl.
	\item Générer et publier automatiquement la documentation technique.
\end{itemize}

\textbf{Avantages principaux} :
\begin{itemize}
	\item Intégration native avec GitLab et l’ensemble du cycle de vie DevOps.
	\item Modèle déclaratif simple et lisible.
	\item Traçabilité et auditabilité complète des pipelines.
	\item Compatibilité avec les conteneurs et les environnements Kubernetes.
	\item Gestion sécurisée des secrets et des variables sensibles.
	\item Large écosystème de templates, exemples et intégrations communautaires.
\end{itemize}

En synthèse, GitLab CI est une solution stratégique pour automatiser l’intégration et la livraison continues. Il permet aux équipes de gagner en efficacité opérationnelle, d’améliorer la qualité logicielle et d’accélérer la mise en production des innovations.

\textbf{Références et documentations} :
\begin{itemize}
	\item GitLab CI Documentation – \url{https://docs.gitlab.com/ee/ci/}
	\item GitLab CI YAML Reference – \url{https://docs.gitlab.com/ee/ci/yaml/}
	\item GitLab Runners – \url{https://docs.gitlab.com/runner/}
	\item GitLab Kubernetes Integration – \url{https://docs.gitlab.com/ee/user/project/clusters/}
\end{itemize}

\subsection{Commitlint}

Commitlint est un outil open source qui permet de vérifier que les messages de commit respectent un format prédéfini. Il est particulièrement utilisé dans les workflows Git modernes pour renforcer la cohérence des messages de commit, faciliter la génération automatique de changelogs et standardiser la documentation des évolutions logicielles. Commitlint est souvent intégré à des processus de validation automatisés grâce aux hooks Git (par exemple avec Husky) ou aux pipelines CI/CD.

%point de vue metier
Commitlint répond à plusieurs enjeux stratégiques  : améliorer la lisibilité de l’historique des changements, garantir une traçabilité complète des évolutions, renforcer la qualité documentaire et faciliter les audits. La standardisation des messages de commit contribue à instaurer une culture de rigueur et de professionnalisation au sein des équipes de développement.

%point de vue logique et technique
, Commitlint s’appuie sur plusieurs concepts essentiels  :
\begin{itemize}
	\item \textbf{Les règles de validation}  : définissent le format attendu des commits (par exemple, le standard Conventional Commits).
	\item \textbf{Le parser}  : analyse le message de commit et vérifie qu’il correspond au schéma spécifié.
	\item \textbf{La configuration}  : fichier \texttt{commitlint.config.js} où l’on définit les règles, les exceptions et les presets.
	\item \textbf{L’intégration avec Husky}  : permet de déclencher la vérification lors du hook \texttt{commit-msg}.
\end{itemize}

Le standard le plus répandu est \textbf{Conventional Commits}, qui impose un format structuré  :
\begin{verbatim}
<type>(<scope>): <subject>

Exemple :
feat(auth): add JWT authentication
fix(api): handle null pointer exception
docs(readme): update installation instructions
\end{verbatim}

Ce format facilite l’automatisation des versions sémantiques (Semantic Versioning) et la génération des changelogs.

\textbf{Exemples et cas d’usage} :
\begin{itemize}
	\item Empêcher la validation d’un commit si le message ne commence pas par un type valide (ex.: feat, fix, chore).
	\item Bloquer les commits dont le titre dépasse une longueur maximale.
	\item Valider automatiquement tous les messages de commit dans un pipeline CI/CD.
	\item Générer des changelogs structurés à partir des commits normalisés.
	\item Appliquer un format de commit homogène sur plusieurs équipes et projets.
\end{itemize}

\textbf{Avantages principaux} :
\begin{itemize}
	\item Standardisation et lisibilité accrue des messages de commit.
	\item Réduction des erreurs et des incohérences documentaires.
	\item Automatisation des processus de release et de génération de changelogs.
	\item Compatibilité avec les pratiques GitOps et CI/CD.
	\item Facilité d’intégration avec Husky et d’autres outils de hooks Git.
\end{itemize}

En synthèse, Commitlint est une brique essentielle pour industrialiser et professionnaliser la gestion des versions et la documentation des projets logiciels. Il contribue à instaurer une culture DevOps rigoureuse et à améliorer la traçabilité du cycle de développement.

\textbf{Références suggérées} :
\begin{itemize}
	\item Commitlint Documentation – \url{https://commitlint.js.org/}
	\item Conventional Commits – \url{https://www.conventionalcommits.org/}
	\item Husky Documentation – \url{https://typicode.github.io/husky/}
	\item Semantic Versioning – \url{https://semver.org/}
	\item GitHub Commitlint Repository – \url{https://github.com/conventional-changelog/commitlint}
\end{itemize}

\subsection{Husky}

Husky est un outil open source permettant de gérer et d’exécuter des hooks Git de manière simple et centralisée dans les projets logiciels. Il facilite l’automatisation de tâches de validation et de mise en conformité lors des événements Git, tels que les commits, les pushs ou les merges. Grâce à sa configuration déclarative, Husky contribue à instaurer des pratiques DevOps rigoureuses et à renforcer la qualité du code tout au long du cycle de développement.

%point de vue metier
Husky répond à plusieurs enjeux stratégiques  : réduire les erreurs humaines, homogénéiser les workflows entre équipes, accélérer le feedback lors des validations et améliorer la traçabilité des changements. Il constitue un levier essentiel de professionnalisation, car il garantit que les standards de qualité (tests, linting, conventions de commit) sont systématiquement respectés avant d’intégrer le code au référentiel principal.

%point de vue logique et technique
, Husky repose sur plusieurs concepts clés  :
\begin{itemize}
	\item \textbf{Les hooks Git}  : scripts déclenchés automatiquement par Git à différents moments du cycle de vie (par exemple \texttt{pre-commit}, \texttt{commit-msg}, \texttt{pre-push}).
	\item \textbf{La configuration}  : Husky utilise des commandes déclarées dans le fichier \texttt{package.json} ou dans des fichiers dédiés (\texttt{.husky/pre-commit}).
	\item \textbf{Les intégrations}  : Husky fonctionne avec de nombreux outils tels que ESLint, Prettier, Commitlint ou les tests unitaires.
	\item \textbf{Le workflow Node.js}  : bien qu’installé via npm ou Yarn, Husky est indépendant du langage utilisé dans le projet.
\end{itemize}

Les hooks les plus fréquemment utilisés sont  :
\begin{itemize}
	\item \texttt{pre-commit}  : exécute des validations avant l’enregistrement d’un commit (linting, tests).
	\item \texttt{commit-msg}  : vérifie que le message de commit respecte une convention donnée.
	\item \texttt{pre-push}  : lance des vérifications avant l’envoi du code sur le dépôt distant.
\end{itemize}

\textbf{Exemples et cas d’usage} :
\begin{itemize}
	\item Lancer ESLint automatiquement sur les fichiers modifiés avant chaque commit.
	\item Exécuter Commitlint pour garantir que les messages de commit respectent Conventional Commits.
	\item Vérifier que les tests unitaires passent avant chaque push.
	\item Appliquer Prettier pour uniformiser le formatage du code source.
	\item Refuser les commits contenant des erreurs de syntaxe ou de style.
	\item Exécuter des scripts personnalisés pour valider des règles métier spécifiques.
	\item Executer des scripts de sécurité pour détecter les vulnérabilités dans les dépendances.
	\item Vérifier que les fichiers de configuration sont à jour , conformes aux standards et ne contiennent pas d'informations sensibles.
	\item Bloquer la création de commits vides ou sans description.
\end{itemize}

\textbf{Avantages principaux} :
\begin{itemize}
	\item Standardisation des processus de validation dans toute l’équipe.
	\item Réduction des erreurs humaines et des régressions en amont des CI/CD.
	\item Facilité de mise en œuvre et de configuration.
	\item Compatibilité avec de nombreux outils de qualité logicielle.
	\item Exécution rapide et locale, sans dépendre de l’environnement distant.
\end{itemize}

En synthèse, Husky est un composant essentiel pour fiabiliser et automatiser les workflows de validation des projets modernes. Il contribue à instaurer une culture DevOps orientée qualité et à renforcer la cohérence entre les contributeurs.

\textbf{Références suggérées} :
\begin{itemize}
	\item Husky Documentation – \url{https://typicode.github.io/husky/}
	\item Git Hooks Documentation – \url{https://git-scm.com/docs/githooks}
	\item Commitlint Documentation – \url{https://commitlint.js.org/}
	\item ESLint Documentation – \url{https://eslint.org/docs/latest/}
	\item Prettier Documentation – \url{https://prettier.io/docs/en/}
\end{itemize}

\textbf{Références suggérées supplémentaires pour la sécurité du code} :
\begin{itemize}
	\item npm Audit Documentation – \url{https://docs.npmjs.com/cli/v10/commands/npm-audit}
	\item Snyk Documentation – \url{https://docs.snyk.io/}
	\item Trivy Documentation – \url{https://aquasecurity.github.io/trivy/}
	\item OWASP Dependency-Check – \url{https://jeremylong.github.io/DependencyCheck/}
	\item Bandit Documentation – \url{https://bandit.readthedocs.io/en/latest/}
\end{itemize}

\subsection{Semantic Release}

Semantic Release est un outil open source qui automatise le versionnement et la publication des packages logiciels en s’appuyant sur les messages de commit et le principe du versionnement sémantique (Semantic Versioning). Il supprime le besoin de mise à jour manuelle du numéro de version et de rédaction des changelogs, contribuant ainsi à la fiabilisation et à l’industrialisation des processus de release.

%point de vue metier
Semantic Release répond à plusieurs enjeux stratégiques  : réduire les erreurs humaines dans les versions publiées, accélérer le cycle de livraison, renforcer la traçabilité des évolutions et homogénéiser les workflows de publication entre équipes. En automatisant intégralement la release, il permet aux développeurs de se concentrer sur la qualité fonctionnelle plutôt que sur les tâches administratives.

%point de vue logique et technique
, Semantic Release repose sur plusieurs concepts clés  :
\begin{itemize}
	\item \textbf{Les conventions de commit}  : le projet s’appuie sur des formats structurés (par exemple Conventional Commits) pour déduire automatiquement l’impact des changements (correctifs, nouvelles fonctionnalités, breaking changes).
	\item \textbf{Le calcul automatique de la version}  : en fonction des types de commits depuis la dernière release, Semantic Release incrémente la version majeure, mineure ou corrective.
	\item \textbf{La génération du changelog}  : compilation automatique des changements pertinents dans un format lisible.
	\item \textbf{La publication}  : déploiement automatisé vers les registres de packages (npm, Maven, Docker Hub) et création des tags Git correspondants.
\end{itemize}

Semantic Release s’intègre naturellement dans des pipelines CI/CD (GitHub Actions, GitLab CI, CircleCI), garantissant que chaque merge dans la branche principale déclenche la création d’une nouvelle version stable.

\textbf{Exemples et cas d’usage} :
\begin{itemize}
	\item Publier automatiquement un package npm lorsque de nouvelles fonctionnalités sont mergées.
	\item Générer un changelog détaillé à partir des commits, sans intervention manuelle.
	\item Tagger les versions dans Git et créer des releases GitHub avec les notes correspondantes.
	\item Déclencher un pipeline de build Docker et pousser l’image versionnée sur un registre.
	\item Refuser les releases en cas de non-respect des conventions de commit.
\end{itemize}

\textbf{Avantages principaux} :
\begin{itemize}
	\item Automatisation complète et fiabilisée du cycle de versionnement et de publication.
	\item Réduction drastique des erreurs humaines et des oublis dans la gestion des versions.
	\item Traçabilité et transparence accrues grâce aux changelogs générés automatiquement.
	\item Compatibilité avec de nombreux systèmes CI/CD et écosystèmes de packaging.
	\item Homogénéité des pratiques de release entre les projets et les équipes.
\end{itemize}

En synthèse, Semantic Release est une solution stratégique pour les organisations souhaitant industrialiser et sécuriser leur processus de publication. Il apporte une cohérence et une rapidité qui renforcent la qualité et la crédibilité des livraisons logicielles.

\textbf{Références suggérées} :
\begin{itemize}
	\item Semantic Release Documentation – \url{https://semantic-release.gitbook.io/}
	\item Conventional Commits – \url{https://www.conventionalcommits.org/}
	\item Semantic Versioning – \url{https://semver.org/}
	\item GitHub Actions Documentation – \url{https://docs.github.com/en/actions}
	\item npm Publishing Guide – \url{https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages}
\end{itemize}
\section{Les conventions de commits}

Les conventions de commits désignent l’ensemble des règles et des bonnes pratiques qui encadrent la rédaction des messages de commit dans un système de gestion de versions (comme Git). Elles visent à standardiser la documentation des changements, à faciliter la compréhension de l’historique d’un projet et à automatiser certaines tâches (génération de changelogs, déclenchement de pipelines CI/CD, versionnement sémantique). Leur adoption contribue à renforcer la qualité des projets logiciels et la collaboration entre les équipes.

%point de vue metier
les conventions de commits permettent de valoriser la traçabilité et la lisibilité du code. Elles facilitent la revue des changements lors des audits, améliorent la communication entre développeurs et garantissent que l’évolution du produit est documentée de façon claire et structurée. Elles sont également un levier de professionnalisation et de crédibilité vis-à-vis des partenaires et des clients, qui attendent des processus de développement rigoureux et transparents.

%point de vue logique et technique
, plusieurs standards de conventions ont émergé, notamment :
\begin{itemize}
	\item \textbf{Conventional Commits} : une spécification populaire qui définit un format structuré basé sur des préfixes et des catégories. Exemple :
	      \begin{verbatim}
    feat(auth): add JWT authentication
    fix(api): correct error handling in user service
    docs(readme): update installation instructions
	      \end{verbatim}
	\item \textbf{Semantic Versioning} : combiné aux conventions de commits, il permet de déclencher automatiquement les incréments de version (MAJOR, MINOR, PATCH) selon la nature des changements.
	\item \textbf{Gitmoji} : l’usage d’emojis standardisés pour symboliser visuellement le type de modification :
	      \begin{verbatim}
    eat: add search functionality
    fix: resolve crash on startup
    docs: improve API documentation
	      \end{verbatim}
\end{itemize}

Les conventions de commits permettent d’automatiser des processus critiques :
\begin{itemize}
	\item Génération de changelogs clairs à partir des messages structurés.
	\item Déclenchement de pipelines CI/CD conditionnés à certains types de changements.
	\item Application automatique de politiques de versionnement.
	\item Vérification des formats de message via des hooks Git (ex. Commitlint).
\end{itemize}

\textbf{Exemples et cas d’usage} :
\begin{itemize}
	\item Utiliser la convention Conventional Commits pour tous les projets d’un département afin de générer automatiquement la documentation des versions.
	\item Configurer un pipeline CI/CD qui refuse les commits non conformes au format attendu.
	\item Associer des préfixes (feat, fix, chore) aux incréments automatiques de version selon Semantic Versioning.
	\item Appliquer des tags de breaking change via l’indication \texttt{BREAKING CHANGE} dans le corps du commit.
\end{itemize}

\textbf{Avantages principaux} :
\begin{itemize}
	\item Lisibilité et compréhension accrues de l’historique des changements.
	\item Automatisation de la génération des notes de version et du versionnement.
	\item Réduction des erreurs humaines grâce aux validations automatiques.
	\item Amélioration de la collaboration et de la revue de code.
	\item Renforcement de la transparence et de la traçabilité du cycle de développement.
\end{itemize}

En synthèse, l’adoption de conventions de commits structurées ne constitue pas uniquement une formalité : elle participe pleinement à l’industrialisation et à la qualité des processus de développement logiciel. Elle s’inscrit dans une démarche globale d’automatisation, de traçabilité et de professionnalisation des projets.

\textbf{Références suggérées} :
\begin{itemize}
	\item Conventional Commits Specification – \url{https://www.conventionalcommits.org/}
	\item Semantic Versioning – \url{https://semver.org/}
	\item Gitmoji – \url{https://gitmoji.dev/}
	\item Pro Git Book – \url{https://git-scm.com/book/en/v2}
	\item Gousios, G., Spinellis, D. (2012). GIT-EVOLVE: A Software Evolution Tool Based on Git.
\end{itemize}

\section{Mise en place des pipelines CI/CD}

La mise en place d’une chaîne CI/CD (Continuous Integration / Continuous Deployment) constitue un levier essentiel pour automatiser la construction, le test et le déploiement des applications.
Ce processus contribue à réduire les délais de mise en production, à limiter les erreurs humaines et à fiabiliser les évolutions logicielles.

\subsection{Conteneurisation des applications}

La première étape du pipeline CI/CD consiste à conteneuriser les applications développées.
Pour ce faire, des fichiers \texttt{Dockerfile} ont été créés pour chaque projet, décrivant :
\begin{itemize}
	\item Le système de base à utiliser (par exemple \texttt{python:3.10-slim}, \texttt{node:lts}).
	\item L’installation des dépendances applicatives via \texttt{pip}, \texttt{npm} ou autres gestionnaires de paquets.
	\item La copie du code source et des fichiers de configuration.
	\item La définition du point d’entrée de l’application (\texttt{ENTRYPOINT}).
\end{itemize}

Cette approche garantit que chaque build produit une image identique, facilement transportable et exécutable dans tout environnement Kubernetes.

\subsection{Tagging des images}

Le tagging des images conteneurisées ne peut pas être aléatoire, car il constitue la base de la traçabilité, de la reproductibilité et de la fiabilité des déploiements. Un schéma de versionnement clair et systématique permet de relier chaque image à son origine exacte et d'éviter toute ambiguïté lors des mises en production.

Tout d'abord, l'utilisation d'un tag unique basé sur le hash du commit Git garantit la \textbf{traçabilité stricte}. Par exemple, lorsqu'un incident survient en production, il est indispensable de savoir précisément quel code source a généré l'image déployée. Si les tags étaient choisis de manière arbitraire ou remplacés sans cohérence (par exemple avec \texttt{latest} écrasé à chaque build), il serait impossible de retrouver la version exacte à l'origine du problème.

Ensuite, un tagging rigoureux assure la \textbf{reproductibilité des environnements}. Lorsqu'un même tag est utilisé dans différents clusters (staging, production), il doit toujours pointer vers la même image. Ainsi, un déploiement appliqué plusieurs semaines plus tard avec le même manifeste Kubernetes sera identique au déploiement initial. Sans cette convention, des différences imprévisibles pourraient introduire des comportements inattendus.

Le schéma de versionnement facilite également le \textbf{rollback} en cas de défaillance. Si une nouvelle version introduit un bug critique, il est possible de restaurer immédiatement l'image antérieure en redeployant le tag correspondant (par exemple \texttt{v1.2.3-main}), sans incertitude sur son contenu.

Enfin, cette approche contribue à la \textbf{sûreté des opérations et à l'auditabilité}. Dans des contextes soumis à des exigences réglementaires (ISO, PCI-DSS) ou à des politiques internes strictes, le tag constitue une preuve technique qui relie chaque binaire à son processus de fabrication (pipeline CI/CD) et à son commit d'origine. Il devient ainsi possible de démontrer qui a produit l'image, à quel moment et avec quelles sources.

Ces cas d'usage illustrent qu'un schéma de tagging structuré est essentiel pour garantir la qualité, la sécurité et la maîtrise des déploiements en environnement conteneurisé.

Le versionnement des images conteneurisées est essentiel pour assurer la traçabilité des déploiements.
Les pipelines CI/CD ont été configurés pour appliquer un schéma de tagging cohérent :
\begin{itemize}
	\item Utilisation d’un tag unique basé sur le hash du commit Git.
	\item Création d’un tag lisible incluant le numéro de version et la branche (par exemple \texttt{v1.2.3-main}).
	\item Marquage automatique de l’image la plus récente comme \texttt{latest} pour simplifier les tests.
\end{itemize}

Ces conventions permettent de relier chaque déploiement Kubernetes à l’image exacte qui a été produite par la pipeline.

\subsection{Configuration de l’authentification}

La sécurité des échanges entre les outils CI/CD et les services externes (registre d’images, dépôt GitOps) repose sur une gestion rigoureuse des identifiants et des autorisations.

Plusieurs mesures ont été mises en œuvre pour garantir une authentification sécurisée :
\begin{itemize}
	\item Création de comptes de service dédiés avec des droits limités.
	\item Génération de tokens d’accès spécifiques à chaque usage.
	\item Stockage sécurisé des identifiants et des tokens via les \textbf{variables GitLab CI/CD}, marquées comme protégées et masquées.
	\item Définition de règles de rotation périodique de ces secrets.
\end{itemize}

\paragraph{Authentification CI/CD vers Harbor (registre d’images)}

Les runners GitLab doivent pouvoir pousser les images Docker construites vers Harbor.

\subparagraph{Étapes de configuration}

\begin{enumerate}
	\item \textbf{Créer un compte robot dans Harbor} :
	      \begin{itemize}
		      \item Accéder au projet ciblé sur Harbor.
		            %       \begin{figure}[H]
		            %       	\centering
		            %       	\includegraphics[width=0.6\textwidth]{figures/projet ciblé.png}
		            %       	\caption{acceder au projet ciblé sur Harbor}
		            %       \end{figure}
		            % \item Onglet \emph{Robot Accounts > New Robot Account}.
		            %       \begin{figure}[H]
		            %       	\centering
		            %       	\includegraphics[width=0.6\textwidth]{figures/creer un compte robot page 1/3.png}
		            %       	\caption{Choisir les paramètres du compte robot sur Harbor}
		            %       \end{figure}
		            %       \begin{figure}[H]
		            %       	\centering
		            %       	\includegraphics[width=0.6\textwidth]{figures/figures/creer un compte robot page 2/3.png}
		            %       	\caption{Choisir les permissions du compte robot sur Harbor}
		            %       \end{figure}
		            %       \begin{figure}[H]
		            %       	\centering
		            %       	\includegraphics[width=0.6\textwidth]{figures/figures/creer un compte robot page 3/3.png}
		            %       	\caption{Choisir projets du compte robot sur Harbor}
		            %       \end{figure}
		      \item Nommer le compte (ex: \texttt{ci-push}), définir les permissions nécessaires (\texttt{push}, \texttt{pull}).
	      \end{itemize}

	\item \textbf{Copier l’identifiant et le token généré} :
	      \begin{itemize}
		      \item Identifiant : \texttt{robot\$ci-push}
		      \item Mot de passe/token : affiché une seule fois à la création.
	      \end{itemize}

	\item \textbf{Ajouter les variables dans GitLab} :
	      \begin{itemize}
		      \item Aller dans \emph{Settings > CI/CD > Variables}.
		      \item Définir :
		            \begin{itemize}
			            \item \texttt{HARBOR\_USERNAME = robot\$ci-push}
			            \item \texttt{HARBOR\_PASSWORD = <token>}
		            \end{itemize}
		      \item Activer \textbf{Protected} et \textbf{Masked}.
	      \end{itemize}

	      %   \begin{figure}[H]
	      %   	\centering
	      %   	\includegraphics[width=0.6\textwidth]{figures/gitlab_ci_vars.png}
	      %   	\caption{Variables CI/CD dans GitLab pour Harbor}
	      %   \end{figure}

	\item \textbf{Authentification dans la pipeline} :

	      \begin{verbatim}
docker-login:
  image: docker:latest
  stage: build
  script:
    - echo "$HARBOR_PASSWORD" | docker login my-harbor.oneex.fr -u "$HARBOR_USERNAME" --password-stdin
    - docker build -t my-harbor.oneex.fr/project/app:$CI_COMMIT_SHORT_SHA .
    - docker push my-harbor.oneex.fr/project/app:$CI_COMMIT_SHORT_SHA
\end{verbatim}

\end{enumerate}

\paragraph{Authentification Argo CD vers GitLab (dépôt GitOps)}

Argo CD doit accéder au dépôt Git contenant les manifests Kubernetes ou les Helm charts à déployer.

\subparagraph{Étapes de configuration}

\begin{enumerate}
	\item \textbf{Créer un token GitLab} :
	      \begin{itemize}
		      \item Aller dans \emph{GitLab > Preferences > Access Tokens}.
		      \item Définir un token avec les scopes : \texttt{read\_repository}, voire \texttt{write\_repository}.
	      \end{itemize}

	      %   \begin{figure}[H]
	      %   	\centering
	      %   	\includegraphics[width=0.6\textwidth]{figures/gitlab_access_token.png}
	      %   	\caption{Création d’un access token GitLab pour Argo CD}
	      %   \end{figure}

	\item \textbf{Ajouter le dépôt dans Argo CD} :
	      \begin{itemize}
		      \item Via la CLI :
		            \begin{lstlisting}[language=bash]
argocd repo add https://gitlab.com/oneex/gitops-repo.git \
  --username <gitlab-username> \
  --password <access-token>
	      	      \end{lstlisting}
		      \item Ou via l’interface graphique : \emph{Settings > Repositories > Connect Repo using HTTPS}.
	      \end{itemize}

	      %   \begin{figure}[H]
	      %   	\centering
	      %   	\includegraphics[width=0.6\textwidth]{figures/argocd_add_repo.png}
	      %   	\caption{Ajout du dépôt GitOps dans Argo CD}
	      %   \end{figure}

	\item \textbf{(Optionnel) Gestion des credentials via Vault ou SealedSecrets} :
	      \begin{itemize}
		      \item Pour éviter le stockage de secrets dans les manifests ou CRDs.
	      \end{itemize}
\end{enumerate}

\vspace{0.5cm}
Ces mécanismes assurent que seuls les outils autorisés peuvent interagir avec Harbor et les dépôts Git, renforçant la sécurité de la chaîne DevOps tout en maintenant une automatisation fluide et traçable.

\subsection{Préparation des tâches des pipelines}

Les tâches élémentaires des pipelines CI/CD ont été définies de manière modulaire.
Elles incluent notamment :
\begin{itemize}
	\item La phase de compilation et de tests unitaires.
	\item La construction des images Docker.
	\item Le scan de sécurité (par exemple avec Trivy) pour détecter les vulnérabilités connues.
	\item La validation syntaxique des manifests Kubernetes (linting).
	\item La mise en cache des dépendances pour accélérer les builds.
\end{itemize}

Chaque tâche est décrite dans un fichier YAML de pipeline et peut être exécutée indépendamment, favorisant la réutilisation entre projets.

\subsection{Préparation des pipelines}

Enfin, les pipelines complets ont été structurés et versionnés dans les dépôts Git des applications.
Ces pipelines définissent :
\begin{itemize}
	\item Les déclencheurs automatiques (push sur la branche principale, création d’une release, merge request).
	\item Les variables d’environnement spécifiques à chaque environnement cible (dev, recette, production).
	\item Les étapes de build, de test, de publication et de déploiement continu.
	\item Les conditions de déclenchement manuel ou automatique de certaines étapes sensibles (par exemple le déploiement en production).
\end{itemize}

L’ensemble du processus CI/CD permet ainsi de passer d’un simple commit de code source jusqu’à la mise à jour des pods Kubernetes de façon totalement automatisée et traçable.